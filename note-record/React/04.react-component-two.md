# React组件化开发（二）

## 一、React性能优化SCU

### 1. React更新机制

![react-render-progress](https://gitee.com/edward_west/image-store/raw/master/study-frontend/react/learn-react/react-render-progress.png)

![react-update-mechanism](https://gitee.com/edward_west/image-store/raw/master/study-frontend/react/learn-react/react-update-mechanism.png)

### 2. React的更新流程

- React在props或state发生改变时，会调用React的render方法，会创建一颗不同的树
- React需要基于这两颗不同的树之间的差别来判断如何有效的更新UI
  - 如果一棵树参考另外一棵树进行完全更新，该算法的复杂度为O(n^2)，其中n是树中元素的数量

- React对这个算法进行了优化，将其优化成了O(n)，如何优化呢
  - 同层节点直接相互比较，不会跨节点比较
  - 不同类型的节点，会产生不同的树结构
  - 开发中，可以通过key来指定哪些节点在不同的渲染下保持稳定

### 3. keys的优化

- 方式一：在最后位置插入数据
  - 这种情况，有无key意义不大

- 方式二：在前面插入数据
  - 这种中法，在没有key的情况下，所有的li都需要进行修改

- 当子元素拥有key时，React使用key来匹配原有树上的子元素以及最新树上的子元素
- key的注意事项
  - key应该是唯一的
  - key不要使用随机数（随机数在下一次render时，会重新生成一个数字）
  - 使用index作为key，对性能是没有优化的

### 4. render函数被调用

- 在以后的开发中，只要是修改了App中的数据，**所有的组件都需要重新render，进行diff算法，性能必然是很低的**
  - 事实上，很多组件没有必要重新render
  - 它们调用render应该有一个前提，就是依赖的数据（state, props）发生改变时，在调用自己的render方法

- 如何控制render方法是否被调用
  - 通过shouldComponentUpdate方法来控制

#### 4.1 shouldComponentUpdate

- React提供了一个生命周期方法shouldComponentUpdate（简称为SCU），这个方法接受参数，并且有返回值（布尔类型）
  - 两个参数
    - 参数一：nextProps，最新的props属性
    - 参数二：nextState，最新的state属性

  - 返回一个boolean类型
    - 返回true，那么就需要调用render方法
    - 返回false，那么不需要调用render方法
    - 默认返回的是true，即默认情况下，只要调用了setState，那么就会调用render方法

#### 4.2 PureComponent

- 如果所有的类组件，都需要手动来实现shouldComponentUpdate，那么给开发者增加非常多的工作量
  - 设想一下shouldComponentUpdate中的各种判断的目的是什么呢？
  - props或者state中的数据是否发生了改变，来决定shouldComponentUpdate是否返回true或者false

- 事实上React考虑了这一点，以及默认实现该功能
  - 将class继承自PureComponent，那么就会自动实现shouldComponentUpdate方法

```jsx
import React, { PureComponent } from 'react'

export class Home extends PureComponent {
  render() {
    console.log('Home render');
    return (
      <div>
        <h2>Home Page - {this.props.message}</h2>
      </div>
    )
  }
}

export default Home

```

#### 4.3 shallowEqual方法

- 这个方法中，调用!shallowEqual(oldProps, newProps)||!shallowEqual(oldState, newState)来判断是否需要更新，这个shallowEqual就是进行浅层比较

#### 4.4 高阶组件memo

- 目前针对类组件可以使用PureComponent，但是函数组件没有这个功能
  - 事实上，函数式组件在props没有改变时，也不希望其重新渲染DOM树结构

- 需要使用一个高阶组件memo
  - 将之前的函数式组件作为参数传递给memo，memo会返回一个新的组件
  - 最终的效果是，只有props发生变化时，才会重新渲染DOM树结构

```jsx
import {memo} from 'react'
// memo 用于函数组件的性能优化
const Profile = memo(function(props) {
  console.log('Profile render')
  return <h2>Profile: {props.message}</h2>
})
export default Profile
```

### 5. 数据不可变的力量

```jsx
import React, { PureComponent } from 'react'
export class App extends PureComponent {
  constructor(){
    super()
    this.state = {
      books: [
        {id: 1, name: '《React进阶实践指南》', price: 59.00, count: 1},
        {id: 2, name: '《React全栈》', price: 69.00, count: 1},
        {id: 3, name: '《React Native》', price: 79.00, count: 1},
        {id: 4, name: '《你不知道的JavaScript》', price: 79.00, count: 1},
      ],
    }
  }
  addNewBook() {
    const newBook = {id: Math.random() * 100, name: '《React Native》', price: 79.00, count: 1}
    // 1. 直接修改原有的state，重新设置一边
    // 在PureComponent中，不能引入重新渲染('re-render')
    // this.state.books.push(newBook)
    // this.setState({ books: this.state.books })
    const books = [...this.state.books, newBook]
    this.setState({ books })
  }
  addBookCount(index) {
    const books = [...this.state.books]
    books[index].count++
    this.setState({ books })
  }
}
```

## 二、获取DOM方式refs

### 1. 如何使用ref

- 在React的开发模式中，通常情况下不需要、也不建议直接操作DOM原生，但是在某些情况下，需要获取DOM元素，比如
  - 管理焦点、文本选择或媒体播放
  - 触发强制动画
  - 继承第三方DOM库
  - 获取DOM元素的滚动位置等

- 如何创建refs来获取对应的DOM呢？
  - 方式一：传入字符串
    - 使用时通过 `this.refs.名称` 来获取对应的DOM元素

  - 方式二：传入一个对象
    - 对象是通过React.createRef()创建的
    - 使用时获取到创建的对象其中有一个current属性是对应的元素

  - 方式三：传入一个函数
    - 函数的参数是对应的DOM元素
    - 使用时，直接拿到之前保存的元素对象即可

```jsx
import React, { PureComponent, createRef } from 'react'
export default class App extends PureComponent {
  constructor() {
    super();
    this.titleRef = createRef();
    this.titleEl = null;
  }
  getNativeDOM() {
    // 1. 方式一：在React元素上绑定一个ref字符串
    // console.log(this.refs.why);

    // 2. 方式二：提前创建好ref对象，createRef()，将创建出来的对象绑定到元素上
    // console.log(this.titleRef.current)

    // 3. 方式三： 回调函数，在对应的元素被渲染之后。会立即执行回调函数，将元素作为参数传入
    console.log(this.titleEl)
  }
  render() {
    return (
      <div>
        <h2 ref="why">Hello World</h2>
        <h2 ref={this.titleRef}>你好啊，李银河！</h2>
        <h2 ref={el => {this.titleEl = el}}>你好啊，世界！</h2>
        <button onClick={e => this.getNativeDOM()}>获取DOM</button>
      </div>
    )
  }
}
```

### 2. ref的类型

- ref的值根据节点类型而有所不同
  - 当ref属性用于HTML元素时，构造函数中使用React.createRef()创建的ref接收底层DOM元素作为其current属性
  - 当ref属性用于自定义class组件时，ref对象接收组件的挂载实例作为其current属性
  - 不能在函数组件上使用ref，因为他们没有实例

- 函数式组件是没有实例的，所有无法通过ref获取他们的实例
  - 但是在某些时候，可能想要获取函数式组件中的某个DOM元素
  - 可以通过React.forwardRef，将ref转发给函数式组件内部的DOM元素，后面也会学习hooks中如何使用ref

```jsx
import React, { PureComponent, createRef } from 'react'
class HelloWorld extends PureComponent{
  test() {
    console.log('test -------');
  }
  render(){
    return (
      <div>
        <h2 ref="why">Hello World</h2>
      </div>
    )
  }
}
const HelloWorldFunC = forwardRef(function(props, ref) {
  return (
    <div>
      <h2 ref={ref}>Hello World</h2>
    </div>
  )
})
export default class App extends PureComponent {
  constructor() {
    super();
    this.classRef = createRef();
    this.funcRef = createRef();
  }
  getComponent() {
    console.log(this.classRef.current)
    this.classRef.current.test();
    console.log(this.funcRef)
  }
  render() {
    return (
      <div>
        {/* 1. 类组件 */}
        <HelloWorld ref={this.classRef}/>
        {/* 2. 函数式组件 */}
        <HelloWorldFunC ref={this.funcRef} />
        <button onClick={e => this.getComponent()}>获取DOM</button>
      </div>
    )
  }
}
```

## 三、受控和非受控组件

### 1. 认识受控组件

- 在React中，HTML表单的处理方式和普通的DOM元素不太一样：表达元素通常会保存在一些内部的state
- 比如下面的HTML表单元素
  - 处理方式是DOM默认处理HTML表单的行为，在用户点击提交时会提交到某个服务器中，并且刷新页面
  - 在React中，并没有禁止这个行为，它依然是有效的
  - 但是通常情况下，会使用JavaScript函数来方便地处理表单提交，同时还可以访问用户填写的表单数据
  - 实现这种效果的标准方式是使用“受控组件”

```jsx
<div>
  {/* 受控组件 */}
  <input value={username} type="text" onChange={e => this.changeInput(e)} />
  {/* 非受控组件 */}
  <input type="text" />
  <h2>userName: {username}</h2>
</div>
```

### 2. 受控组件基本演练

## 四、React的高阶组件

## 五、portals和fragment

## 六、StrictMode严格模式

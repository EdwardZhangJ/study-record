# React组件化开发（二）

## 一、React性能优化SCU

### 1. React更新机制

![react-render-progress](https://gitee.com/edward_west/image-store/raw/master/study-frontend/react/learn-react/react-render-progress.png)

![react-update-mechanism](https://gitee.com/edward_west/image-store/raw/master/study-frontend/react/learn-react/react-update-mechanism.png)

### 2. React的更新流程

- React在props或state发生改变时，会调用React的render方法，会创建一颗不同的树
- React需要基于这两颗不同的树之间的差别来判断如何有效的更新UI
  - 如果一棵树参考另外一棵树进行完全更新，该算法的复杂度为O(n^2)，其中n是树中元素的数量

- React对这个算法进行了优化，将其优化成了O(n)，如何优化呢
  - 同层节点直接相互比较，不会跨节点比较
  - 不同类型的节点，会产生不同的树结构
  - 开发中，可以通过key来指定哪些节点在不同的渲染下保持稳定

### 3. keys的优化

- 方式一：在最后位置插入数据
  - 这种情况，有无key意义不大

- 方式二：在前面插入数据
  - 这种中法，在没有key的情况下，所有的li都需要进行修改

- 当子元素拥有key时，React使用key来匹配原有树上的子元素以及最新树上的子元素
- key的注意事项
  - key应该是唯一的
  - key不要使用随机数（随机数在下一次render时，会重新生成一个数字）
  - 使用index作为key，对性能是没有优化的

### 4. render函数被调用

- 在以后的开发中，只要是修改了App中的数据，**所有的组件都需要重新render，进行diff算法，性能必然是很低的**
  - 事实上，很多组件没有必要重新render
  - 它们调用render应该有一个前提，就是依赖的数据（state, props）发生改变时，在调用自己的render方法

- 如何控制render方法是否被调用
  - 通过shouldComponentUpdate方法来控制

#### 4.1 shouldComponentUpdate

- React提供了一个生命周期方法shouldComponentUpdate（简称为SCU），这个方法接受参数，并且有返回值（布尔类型）
  - 两个参数
    - 参数一：nextProps，最新的props属性
    - 参数二：nextState，最新的state属性

  - 返回一个boolean类型
    - 返回true，那么就需要调用render方法
    - 返回false，那么不需要调用render方法
    - 默认返回的是true，即默认情况下，只要调用了setState，那么就会调用render方法

#### 4.2 PureComponent

- 如果所有的类组件，都需要手动来实现shouldComponentUpdate，那么给开发者增加非常多的工作量
  - 设想一下shouldComponentUpdate中的各种判断的目的是什么呢？
  - props或者state中的数据是否发生了改变，来决定shouldComponentUpdate是否返回true或者false

- 事实上React考虑了这一点，以及默认实现该功能
  - 将class继承自PureComponent，那么就会自动实现shouldComponentUpdate方法

```jsx
import React, { PureComponent } from 'react'

export class Home extends PureComponent {
  render() {
    console.log('Home render');
    return (
      <div>
        <h2>Home Page - {this.props.message}</h2>
      </div>
    )
  }
}

export default Home

```

#### 4.3 shallowEqual方法

- 这个方法中，调用!shallowEqual(oldProps, newProps)||!shallowEqual(oldState, newState)来判断是否需要更新，这个shallowEqual就是进行浅层比较

#### 4.4 高阶组件memo

- 目前针对类组件可以使用PureComponent，但是函数组件没有这个功能
  - 事实上，函数式组件在props没有改变时，也不希望其重新渲染DOM树结构

- 需要使用一个高阶组件memo
  - 将之前的函数式组件作为参数传递给memo，memo会返回一个新的组件
  - 最终的效果是，只有props发生变化时，才会重新渲染DOM树结构

```jsx
import {memo} from 'react'
// memo 用于函数组件的性能优化
const Profile = memo(function(props) {
  console.log('Profile render')
  return <h2>Profile: {props.message}</h2>
})
export default Profile
```

### 5. 数据不可变的力量

```jsx
import React, { PureComponent } from 'react'
export class App extends PureComponent {
  constructor(){
    super()
    this.state = {
      books: [
        {id: 1, name: '《React进阶实践指南》', price: 59.00, count: 1},
        {id: 2, name: '《React全栈》', price: 69.00, count: 1},
        {id: 3, name: '《React Native》', price: 79.00, count: 1},
        {id: 4, name: '《你不知道的JavaScript》', price: 79.00, count: 1},
      ],
    }
  }
  addNewBook() {
    const newBook = {id: Math.random() * 100, name: '《React Native》', price: 79.00, count: 1}
    // 1. 直接修改原有的state，重新设置一边
    // 在PureComponent中，不能引入重新渲染('re-render')
    // this.state.books.push(newBook)
    // this.setState({ books: this.state.books })
    const books = [...this.state.books, newBook]
    this.setState({ books })
    
  }
}
```

## 二、获取DOM方式refs

## 三、受控和非受控组件

## 四、React的高阶组件

## 五、portals和fragment

## 六、StrictMode严格模式

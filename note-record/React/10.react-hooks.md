# React Hooks

## 一、认识和体验Hooks

### 1. 为什么需要Hook？

### 2. Class组件存在的问题

- 复杂组件变得难以理解
- 难以理解的class
- 组件复用状态很难

### 3. Hook的出现

- Hook的出现，可以解决上面提到的问题
- 总结一下hooks：
  - 可以让我们在不编写class的情况下使用state以及其他的React特性
  - 可以由此延伸出非常多的用法，让前面所提到的问题得到解决

- Hook的使用场景

### 4. Class组件和Functional组件对比

#### 4.1 计数器案例对比

## 二、State/Effect

### 1. useState解析

### 2. 认识useState

### 3. 认识Effect Hook

### 4. 需要清除Effect

### 5. 使用多个Effect

### 6. Effect性能优化

- 默认情况下，useEffect的回调函数会在每次渲染时都重新执行，但是会导致两个问题
  - 某些代码只希望执行一次，类似于componentDidMount和componentWillUnmount中完成的事情（比如网络请求、订阅和取消订阅）
  - 另外，多次执行也会导致一定的性能问题

- 如何决定useEffect在什么时候应该执行和什么时候不应该执行呢？
  - useEffect实际上有两个参数
  - 参数一：执行的回调函数
  - 参数二：该useEffect在哪些state发生变化时，才重新执行

- 但是，如果一个函数不希望依赖任何的内容时，也可以传入一个空的数组 []
  - 那么这里的两个回调函数分别对应的就是componentDidMount和componentWillUnmount生命周期函数了

## 三、Context/Reducer

### 1. useContext的使用

- 在组件中使用共享的Context有两种方式
  - 类组件可以通过 类名.contextType = MyContext 来使用，在来钟获取context
  - 多个Context或者在函数中通过 MyContext.Consumer 方式共享context

- 但是多个Context共享时的方式会存在大量的嵌套
  - Context Hook允许通过Hook来直接获取某个Context的值

```jsx
const App = memo(() => {
  // 使用 Context
  const user = useContext(UserContext)
  const theme = useContext(ThemeContext)
  
  return (
    <div>
      <h3>user: {user.name}</h3>
      <h3>theme: {theme.color}</h3>
    </div>
  )
})
```

- 注意事项
  - 当组件最上层的<MyContext.Provider>更新时，该Hook会触发重新渲染，并使用最新传递给MyContext provider的context value值

### 2. useReducer的使用

- useReducer仅仅是useState的一种替代方案
  - 在某些场景下，如果state的处理逻辑比较复杂，可以通过useReducer进行拆分
  - 或者这次修改的state需要依赖之前的state，也可以使用

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {...state, count: state.count + 1}
    case 'decrement':
      return {...state, count: state.count - 1}
    case 'add_number':
      return {...state, count: state.count + action.num}
    case 'sub_number': 
      return {...state, count: state.count - action.num}
  }
}
const App = memo(() => {
  const [state, dispatch] = useReducer(reducer, { count: 0 })
  return (
    <div>
      <h2>当前计数：{state.count}</h2>
      <button onClick={e => dispatch({type: 'increment'})}>+1</button>
      <button onClick={e => dispatch({type: 'decrement'})}>-1</button>
      <button onClick={e => dispatch({type: 'add_number', num: 5})}>+5</button>
      <button onClick={e => dispatch({type: 'sub_number', num: 5})}>-5</button>
    </div>
  )
})
```

## 四、Callback/Memo

### 1. useCallback

- useCallback实际目的是为了进行性能优化
- 如何进行性能的优化呢？
  - useCallback会返回一个函数的 memoized（记忆） 值
  - 在依赖不变的情况下，多次定义的时候，返回的值是相同的

```jsx
const increment = useCallback(
  () => {
    setCount(count + 1)
  },
  []
)
```

- 案例
  - 案例一：使用useCallback和不使用useCallback定义一个函数是否会带来性能的优化
  - 案例二：使用useCallback和不使用useCallback定义一个函数传递给子组件是否会带来性能的优化

- 通常使用useCallback的目的是不希望子组件进行多次渲染，并不是为了函数进行缓存

### 2. useMemo

- useMemo的实际作用也是为了进行性能优化
- 如何进行性能的优化呢？
  - useMemo返回的是一个memoized（记忆）值
  - 在依赖不变的情况下，多次定义的时候，返回的值是相同的

```jsx
let result = useMemo(() => { return calcNumTotal(50) }, [])
```

- 案例
  - 案例一：进行大量的计算操作，是否有必须要每次渲染时都重新计算
  - 案例二：对子组件传递相同内容的对象时，使用useMemo进行性能的优化

## 五、Ref/LayoutEffect

### 1. useRef

### 2. useImperativeHandle

### 3. useLayoutEffect

- useLayoutEffect和useEffect的一点区别
  - useEffect会在渲染的内容更新到DOM上后执行，不会阻塞DOM的更新
  - useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新

## 六、自定义Hooks使用

### 1. 自定义Hook

- 自定义Hook严格

### 2. 自定义Hook练习

1. 需求一：Context共享
2. 需求二：获取滚动位置
3. 需求三：

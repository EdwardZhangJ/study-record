# React Hooks

## 一、认识和体验Hooks

### 1. 为什么需要Hook？

### 2. Class组件存在的问题

- 复杂组件变得难以理解
- 难以理解的class
- 组件复用状态很难

### 3. Hook的出现

- Hook的出现，可以解决上面提到的问题
- 总结一下hooks：
  - 可以让我们在不编写class的情况下使用state以及其他的React特性
  - 可以由此延伸出非常多的用法，让前面所提到的问题得到解决

- Hook的使用场景

### 4. Class组件和Functional组件对比

#### 4.1 计数器案例对比

## 二、State/Effect

### 1. useState解析

### 2. 认识useState

### 3. 认识Effect Hook

### 4. 需要清除Effect

### 5. 使用多个Effect

### 6. Effect性能优化

- 默认情况下，useEffect的回调函数会在每次渲染时都重新执行，但是会导致两个问题
  - 某些代码只希望执行一次，类似于componentDidMount和componentWillUnmount中完成的事情（比如网络请求、订阅和取消订阅）
  - 另外，多次执行也会导致一定的性能问题

- 如何决定useEffect在什么时候应该执行和什么时候不应该执行呢？
  - useEffect实际上有两个参数
  - 参数一：执行的回调函数
  - 参数二：该useEffect在哪些state发生变化时，才重新执行

- 但是，如果一个函数不希望依赖任何的内容时，也可以传入一个空的数组 []
  - 那么这里的两个回调函数分别对应的就是componentDidMount和componentWillUnmount生命周期函数了

## 三、Context/Reducer

### 1. useContext的使用

- 在组件中使用共享的Context有两种方式
  - 类组件可以通过 类名.contextType = MyContext 来使用，在来钟获取context
  - 多个Context或者在函数中通过 MyContext.Consumer 方式共享context

- 但是多个Context共享时的方式会存在大量的嵌套
  - Context Hook允许通过Hook来直接获取某个Context的值

```jsx
const App = memo(() => {
  // 使用 Context
  const user = useContext(UserContext)
  const theme = useContext(ThemeContext)
  
  return (
    <div>
      <h3>user: {user.name}</h3>
      <h3>theme: {theme.color}</h3>
    </div>
  )
})
```

- 注意事项
  - 当组件最上层的<MyContext.Provider>更新时，该Hook会触发重新渲染，并使用最新传递给MyContext provider的context value值

### 2. useReducer的使用

- useReducer仅仅是useState的一种替代方案
  - 在某些场景下，如果state的处理逻辑比较复杂，可以通过useReducer进行拆分
  - 或者这次修改的state需要依赖之前的state，也可以使用

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {...state, count: state.count + 1}
    case 'decrement':
      return {...state, count: state.count - 1}
    case 'add_number':
      return {...state, count: state.count + action.num}
    case 'sub_number': 
      return {...state, count: state.count - action.num}
  }
}
const App = memo(() => {
  const [state, dispatch] = useReducer(reducer, { count: 0 })
  return (
    <div>
      <h2>当前计数：{state.count}</h2>
      <button onClick={e => dispatch({type: 'increment'})}>+1</button>
      <button onClick={e => dispatch({type: 'decrement'})}>-1</button>
      <button onClick={e => dispatch({type: 'add_number', num: 5})}>+5</button>
      <button onClick={e => dispatch({type: 'sub_number', num: 5})}>-5</button>
    </div>
  )
})
```


## 四、Callback/Memo

## 五、Ref/LayoutEffect

## 六、自定义Hooks使用

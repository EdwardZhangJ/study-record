# Performance Optimization

* 性能优化目的：更快的加载和响应速度、更稳定的功能表现、更简洁的代码与架构设计、更好用更人性化

## 1. 优化策略

* 前端加载性能：减少首屏加载时间和资源体积，优化用户体验。
* 运行时性能：提高页面渲染和交互的流畅性，降低资源占用。
* 稳定性和可靠性：确保在高并发或复杂场景下的性能表现一致。
* 代码维护性：通过简洁、高效的代码实现功能，降低技术债务和后续开发成本。

### 1.1. 加载 - 性能优化

#### 1.1.1 资源优化

* 删除冗余代码

* 方法一：Tree Shaking(是一种通过静态分析移除未使用代码的技术，通常用来优化前端项目中的 JavaScript 和 CSS 代码)。
  * 原理：Tree Shaking核心依赖于ES Module 规范(import/export)，ES Module 是静态的，可以在编译构建时分析出模块之间的依赖关系。（CommonJS(require/module.exports)是动态导入的，难以在编译时进行静态分析，不支持Tree Shaking）
  * **前端项目使用：**
    1. 使用ESM格式的模块：确保代码使用import/export,避免使用require/module.exports
    2. 使用打包工具支持：Webpack/vite等
    3. 静态导入：避免动态导入或在运行条件下选择模块
    4. 避免副作用(Side Effects)：如果模块导入时有副作用（如修改全局变量、执行代码等），打包工具会保留它，需要在`package.json`中配置`"sideEffects": false`，告诉打包工具可以安全地删除未使用的模块。
  * 针对模块级别的冗余代码删除，tree-shaking比较得心应手，但是更细颗粒度的删除，还需要依赖其他手段。
* 方法二：压缩插件优化删除
  * JavaScript的压缩和优化
    * 通过工具：UglifyJS、Terser、Babel等，可以删除未被引用的代码片段、简化表达式、内联变量等。
  * CSS的压缩和优化
    * 未使用的CSS选择器可以通过工具删除，如PurgeCSS、PurifyCSS等。

* 按需加载（包含懒加载）

* 按需加载（On-demand Loading） 是前端优化的一种核心手段，指在应用运行过程中，仅在用户需要时动态加载特定资源（如JavaScript 代码、CSS 文件、组件、图片等），而非一次性加载所有资源。
  * 核心思想：延迟加载非必要内容，类似于分批处理任务，通过减少初始加载量来提升性能。
  * 主要体现：
    * 减少首屏加载时间
    * 优化性能
    * 节省带宽
    * 提升交互体验
  * **前端项目使用：**
    * 代码层面的动态导入： 通过JavaScript动态导入(import())，在代码执行到某个逻辑时在加载对应的模块，而不是在页面加载时就全部加载，主要应用于大型前端项目，避免一次性加载全部JavaScript代码。使用场景：第三方库按需加载、大型组件加载、页面内嵌功能的动态加载等。
    * 组件级的懒加载：在React、Vue等前端框架中，可以使用 lazy、Suspense(React)、defineAsyncComponent(Vue)等方式实现组件的按需加载。React使用场景：大组件、弹窗、富文本编辑器等复杂组件的按需加载。Vue使用场景：Vue 组件按需加载，减少初始 bundle 体积。
    * 图片和静态资源的懒加载：对于图片等静态资源，可以使用 懒加载（Lazy Load） 技术，在用户 滚动到图片可见时才加载。
    * 路由级的懒加载：适用场景：大型单页应用（SPA）优化首屏加载速度
    * 数据的按需加载：在请求接口时，只加载当前需要的数据，减少不必要的请求和数据传输量。适用场景：表格分页、无限滚动、搜索结果分页。
  * **实际如何使用以达到项目整体的按需加载**
    * 分析项目需求：找出哪些资源可以按需加载（JS 代码、组件、图片、路由、**数据等**）一般可以通过一些插件来分析打包的产物，看看哪些产物比较大且又是初始化的时候不需要加载的，可以单独抽出来按需加载。
    * 使用Webpack/Vite代码分割，通过import()进行动态加载
    * 优化图片加载
    * 使用路由懒加载
    * 合理进行数据加载优化

* 细颗粒度的代码分割（利用缓存策略）
  * 常见缓存策略是：html文件不缓存，每次都请求最新的html文件。静态资源文件时通过构建工具打了hash值的tag，只要资源文件发生变化就会生产新hash，从而命中不了缓存，达到获取新资源的目的。
* 开启gzip压缩
  * 常见的压缩资源方式，可以通过对HTTP响应内容进行压缩，减小文件的体积。在前端开发中，Gzip压缩主要应用于HTTP响应中传输的文本文件（如HTML、CSS、JavaScript等）

* 图片体积优化
  * 常见图片类型：JPG、PNG、GIF、SVG、WebP、AVIF
    * 根据图片格式可分为：传统图片格式 JPG、PNG、GIF、SVG；现代图片格式 WebP、AVIF
    * 根据功能和性能：体积 传统格式的图片文件普通较大。与JPG格式相比，WebP格式通常可以将文件提交减少约10%，而AVIF格式能减少超过40%的体积；性能 现代格式支持更多特性，如动态图片和无损压缩等，而传统格式的特性相对单一；兼容性 代格式的浏览器兼容性稍逊一筹，支持它们的浏览器数量相对较少。

  * **如何进行图片性能优化？**
    * 选择合适的图片格式：照片类优先使用JPG或WebP，图标和UI元素则使用SVG或WebP。对于需要透明度的图片，优先使用WebP或AVIF
    * 使用现在格式：尽可能使用WebP和AVIF等现代格式，结合 `<picture>` 元素
    * 调整图片质量与尺寸：在不显著影响视觉效果的前提下，降低图片的质量和尺寸
    * 图片懒加载：当图片即将进入视口时才会加载，减少初始页面加载的资源消耗
    * 使用CDN
    * 自动化优化工具：使用构建工具和图片处理工具自动化优化图片
    * 图像精灵：

#### 1.1.2 请求优化

* 在前端性能优化中，缓存是一个非常重要的手段，能够显著提高网页的加载速度，减少服务器请求，减轻网络压力，从而提升用户体验。通过合理使用缓存，我们可以在不同场景下存储数据和资源，避免重复加载和计算，提升响应速度。
* 缓存的类型：
  * 浏览器缓存（Client-side Cache）：是在用户浏览器中存储资源（如图片、CSS、JS文件等），以便在下一次访问同一页面时无需重新下载这些资源。
  * DNS缓存：是指在本地设备（如浏览器、操作系统、路由器等）中缓存DNS解析结果的机制。在首次访问某个域名时，DNS解析器会向域名的DNS服务器发起请求来获取域名的IP地址。为了避免每次都需要重新解析相同的域名，DNS结果会被缓存一段时间，这段时间被称为TTL
  * HTTP缓存（Server-side Cache）：是指在服务器与客户端之间通过HTTP协议进行的缓存处理。服务器会将请求的数据缓存下来，若下次相同请求到来，直接返回缓存的内容，而不再进行计算或查询。常见的缓存策略有：客户端缓存、代理缓存（如CDN缓存）、服务器缓存等。
  * CND缓存：是通过将静态资源（如图片、JS、CSS等）分发到全球各地的CDN节点，减少用户请求的响应时间。CDN缓存提高了静态资源加载的速度，并减轻了源服务器的压力。
  * 内存缓存：内存缓存是将常用数据存储在内存中，减少磁盘I/O操作，提高访问速度。常见的内存缓存技术有：Redis、Memcached。
  * 本地存储（Local Storage/Session Storage）:LocalStorage：浏览器提供的一种持久化存储方式，数据不会过期，适合存储不频繁变化的数据，如用户信息、设置等；SessionStorage：与LocalStorage类似，但数据仅在当前会话期间有效。适用于存储会话级别的临时数据。
  * Service Worker缓存：是一个可以在后台线程运行的JavaScript，它能够拦截网络请求并将响应存储到缓存中。Service Worker缓存主要用于支持离线功能，使得应用能够在没有网络的情况下继续运行。
* **如何通过缓存来提升性能？**
  * 浏览器缓存：分为两个核心概念强缓存和协商缓存，
    * 强缓存：最常见的缓存方式，会直接判断资源是否在缓存有效期内，如果在有效期内，则直接使用缓存资源，不再请求服务器。通过设置HTTP响应头中的Cache-Control和Expires字段来控制缓存策略。

### 1.2 渲染 - 性能优化
